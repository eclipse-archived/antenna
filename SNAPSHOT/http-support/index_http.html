<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 at 2020-06-18 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20200618" />
    <meta http-equiv="Content-Language" content="en" />
    <title>antenna-documentation &#x2013; The HTTP support library</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
      <script type="text/javascript" src="../js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarDisabled">
      <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>Antenna Documentation</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2020-06-18<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0.0-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Overview</li>
    <li><a href="../index.html" title="About"><span class="none"></span>About</a>  </li>
    <li><a href="../getting-started.html" title="Getting started"><span class="none"></span>Getting started</a>  </li>
    <li><a href="../how-to-use.html" title="How to use Antenna"><span class="icon-chevron-down"></span>How to use Antenna</a>
      <ul class="nav nav-list">
    <li><a href="../antenna-cli/index.html" title="Command Line Interface"><span class="none"></span>Command Line Interface</a>  </li>
    <li><a href="../antenna-gradle-plugin/index.html" title="Gradle Plugin"><span class="none"></span>Gradle Plugin</a>  </li>
    <li><a href="../antenna-maven-plugin/index.html" title="Maven"><span class="none"></span>Maven</a>  </li>
      </ul>
  </li>
    <li><a href="../troubleshooting.html" title="Troubleshooting"><span class="none"></span>Troubleshooting</a>  </li>
    <li><a href="../compliance-tool/index.html" title="Compliance Tool"><span class="none"></span>Compliance Tool</a>  </li>
          <li class="nav-header">Development</li>
    <li><a href="../how-to-configure.html" title="How to configure Antenna"><span class="icon-chevron-down"></span>How to configure Antenna</a>
      <ul class="nav nav-list">
    <li><a href="../tool-configuration.html" title="Tool Configuration"><span class="none"></span>Tool Configuration</a>  </li>
    <li><a href="../config-configuration.html" title="config.xml"><span class="none"></span>config.xml</a>  </li>
    <li><a href="../workflow-configuration.html" title="Workflow Configuration"><span class="icon-chevron-down"></span>Workflow Configuration</a>
      <ul class="nav nav-list">
    <li><a href="../analyzers/analyzers.html" title="Analyzers"><span class="none"></span>Analyzers</a>  </li>
    <li><a href="../processors/processors.html" title="Processors"><span class="none"></span>Processors</a>  </li>
    <li><a href="../generators/generators.html" title="Generators"><span class="none"></span>Generators</a>  </li>
    <li><a href="../outputHandlers/outputHandlers.html" title="Output Handlers"><span class="none"></span>Output Handlers</a>  </li>
      </ul>
  </li>
      </ul>
  </li>
    <li><a href="../dev-guide.html" title="Development Guide"><span class="none"></span>Development Guide</a>  </li>
    <li class="active"><a href="#"><span class="none"></span>HTTP Support Library</a>
  </li>
  </ul>
          <hr />
          <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>The HTTP support library</h1>
<p>During an Antenna execution it is typically necessary to communicate with one or multiple HTTP servers. Examples include the download of artifacts from a repository or the interaction with an SW360 instance. Custom workflow step implementations may also contact specific servers to obtain additional information about the software components used by a project.</p>
<p>While doing HTTP requests is not rocket science, it is nevertheless inefficient and error prone if every component that requires this communication comes with its own implementation. There are a number of aspects to be taken into account:</p>
<ul>

<li>HTTP clients are often complex objects making use of expensive resources like thread pools and connection pools. Having multiple clients in a single Antenna run is therefore a waste of resources, especially as HTTP clients are typically thread-safe and can be shared between multiple components.</li>
<li>Configuring an HTTP client is not trivial; basic settings from the Antenna configuration, such as Proxy settings or timeouts, should be taken into account to make sure that all HTTP connections behave in a uniform way.</li>
<li>Resource and error handling when sending HTTP requests can become tricky. It must be ensured that all resources are correctly released even in case of failure responses and exceptions thrown during processing.</li>
<li>If many requests are to be sent - e.g. when downloading a number of artifacts -, performance can be improved by making use of threading and parallelism. This complicates the programming model significantly though.</li>
</ul>
<p>To deal with these issues, Antenna provides a simple to use HTTP client library that can be used by all components taking part in an Antenna execution. The library manages a central, fully configured HTTP client that offers the following features:</p>
<ul>

<li>HTTP requests can be defined in a declarative way making use of a domain specific language (DSL).</li>
<li>The API is lambda-friendly; for instance the processing of a response can be done by a lambda expression.</li>
<li>Resource management is handled by the library; client code does not have to close responses or entities, or use means like try-with-resources.</li>
<li>The programming model is reactive using <i>CompletableFutures</i> to allow for the efficient processing of many requests. There is, however, an easy means to support blocking calls as well.</li>
<li>JSON processing is directly supported, as this is a standard protocol used by many APIs.</li>
<li>Support for multipart requests that are used for instance for file upload operations.</li>
</ul>
<p>The library is implemented by the <i>http-support</i> sub module of the Antenna project. It has comprehensive Javadoc which can be consulted for detail questions. This document provides a short user&#x2019;s guide.</p>
<div class="section">
<h2><a name="Obtaining_the_HTTP_client"></a>Obtaining the HTTP client</h2>
<p>The <i>HttpClientFactory</i> interface and its default implementation <i>HttpClientFactoryImpl</i> are responsible for creating and setting up new instances of <i>HttpClient</i>. The factory interface defines a <i>newHttpClient()</i> method, which expects an <i>HttpClientConfig</i> object as its single argument.</p>
<p><i>HttpClientConfig</i> allows setting a number of properties that impact the behavior of the client instance. An instance with default settings is available via the static <i>basicConfig()</i> method. Using this as a starting point, other properties can be set using methods starting with the prefix <tt>with</tt>. Such methods return a modified copy of the current configuration; <i>HttpClientConfig</i> itself is immutable, and thus instances can be safely shared between different components.</p>
<p>The properties that can be changed in a client configuration are the following: * A JSON object mapper: This object is used to serialize Java objects to generate the payload for JSON requests. * Proxy settings: Requests can be routed through an HTTP proxy. For this purpose, the <i>ProxySettings</i> class exists that collects the properties of the proxy server. * SSL Certificate Verification: Dynmically, ssl certificate verification can be disabled by setting the system property <i>client.access.unverified</i> to true.</p>
<p>Below is a code fragment that shows the construction of an <i>HttpClientConfig</i> instance and the creation of a new HTTP client based on this configuration. For this example we use a very verbose configuration that sets all the properties supported:</p>

<div>
<div>
<pre class="source">ProxySettings proxy = ProxySettings.useProxy(&quot;my.proxy.host&quot;, 8080);
ObjectMapper customMapper = new ObjectMapper()
  .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
HttpClientConfig clientConfig = HttpClientConfig.basicConfig()
  .withProxySettings(proxy)
  .withObjectMapper(customMapper);

HttpClientFactory clientFactory = new HttpClientFactoryImpl();
HttpClient httpClient = clientFactory.newHttpClient(clientConfig);
</pre></div></div>
</div>
<div class="section">
<h2><a name="The_HttpClient_interface"></a>The HttpClient interface</h2>
<p>The central interface for the execution of HTTP requests is <i>HttpClient</i>. It is a very lean interface with only a single <i>execute()</i> method:</p>

<div>
<div>
<pre class="source">    &lt;T&gt; CompletableFuture&lt;T&gt; execute(Consumer&lt;? super RequestBuilder&gt; producer,
                                     ResponseProcessor&lt;? extends T&gt; processor);
</pre></div></div>

<p>The method references the following components:</p>
<ul>

<li>A <i>Consumer</i> of the interface <i>RequestBuilder</i> is passed in as the first parameter. This object defines the request to be executed. We will see a bit later how a request definition looks like with this approach.</li>
<li>The second parameter is a <i>ResponseProcessor</i>. This is a generic functional interface that is passed a <i>Response</i> object (representing the response returned from the server) and produces a result object of a specific type. Here the logic is encapsulated to evaluate the data sent by the server.</li>
<li>The result of <i>execute()</i> is a <i>CompletableFuture</i> of the result type produced by the <i>ResponseProcessor</i>. This shows that requests are made in an asynchronous fashion. The resulting future contains either the result generated by the <i>ResponseProcessor</i> or is failed exceptionally, in case of a connection error or if the <i>ResponseProcessor</i> has thrown an exception. Using <i>CompletableFuture</i> as return value has advantages over conventional, callback-based approaches; especially if the results of multiple requests are to be combined or if some requests depend on the results of others, the ability to chain and compose futures comes in very handy.</li>
</ul>
<div class="section">
<h3><a name="Defining_requests"></a>Defining requests</h3>
<p>The <i>HttpClient</i> interface expects that a request to be executed is defined by an object implementing the standard <i>Consumer</i> interface for objects of type <i>RequestBuilder</i>. <i>RequestBuilder</i> is a fluent builder interface that allows setting various properties of an HTTP request: * the URL of the server to be called * the HTTP method, such as GET or POST * HTTP headers * the body of the request</p>
<p>The only mandatory property which must be set is the request URL. In this case, a GET request to this URL (without any headers) is executed. The following fragment shows an example:</p>

<div>
<div>
<pre class="source">httpClient.execute(builder -&gt;
    builder.uri(&quot;https://www.google.com&quot;), ...
</pre></div></div>

<p>Notice that it is not necessary to invoke some kind of <i>build()</i> method on the passed in builder object; only the desired request properties need to be initialized. For setting headers, the builder&#x2019;s <i>header()</i> method can be used:</p>

<div>
<div>
<pre class="source">httpClient.execute(builder -&gt;
    builder.uri(&quot;https://my.server.com&quot;)
        .header(&quot;Authorization&quot;, &quot;Basic ...&quot;), ...
</pre></div></div>

<p>For requests of type POST or PUT, a request body or entity is typically required. In addition, the concrete HTTP method to be used must be defined. The body is constructed via a dedicated builder interface named <i>RequestBodyBuilder</i>. Here the same approach is followed as for defining the request as a whole: in order to set the body, the <i>body()</i> method of <i>RequestBuilder</i> must be called passing in a <i>Consumer</i> of type <i>RequestBodyBuilder</i>. Using the body builder, the content of the request body can be set in various flavours; for instance as a plain string:</p>

<div>
<div>
<pre class="source">httpClient.execute(builder -&gt;
    builder.uri(&quot;https://my.endpoint.org&quot;)
        .method(RequestBuilder.Method.POST)
        .body(body -&gt; body.string(&quot;This is the request payload.&quot;, 
             HttpConstants.CONTENT_TEXT_PLAIN)), ...
</pre></div></div>

<p>The second parameter of the <i>string()</i> method is the Mime type of the content. (Note the use of the <i>HttpConstants</i> class which offers a bunch of constants related to HTTP headers, content types, status codes, etc.) The HTTP method of the request is specified using an enumeration class.</p>
<p>In addition to plain strings, the body of a request can be defined in other formats as well. As many HTTP-based APIs use JSON payloads, there is a special support for this protocol in form of the <i>json()</i> method of <i>RequestBodyBuilder</i>. The method is passed the object representing the payload. It is serialized to JSON using an internal JSON object mapper, and a content header for the MIME type <i>application/json</i> is automatically added. The example fragment below shows how a PUT request with JSON data can be constructed:</p>

<div>
<div>
<pre class="source">Car myCar = new Car(...);  // object representation of payload
httpClient.execute(builder -&gt;
    builder.uri(&quot;https://my.endpoint.org/cars/42&quot;)
        .method(RequestBuilder.Method.PUT)
        .body(body -&gt; body.json(myCar)), ...
</pre></div></div>

<p>The use case to upload a file is handled by the <i>file()</i> method of <i>RequestBodyBuilder</i>. The method expects the path of the file to be uploaded and a string constant with the MIME type of the file:</p>

<div>
<div>
<pre class="source">Path file = ...;  // file to be uploaded
httpClient.execute(builder -&gt;
    builder.uri(&quot;https://my.endpoint.org/uploads&quot;)
        .method(RequestBuilder.Method.PATCH)
        .body(body -&gt; body.file(file, HttpConstants.CONTENT_OCTET_STREAM)), ...
</pre></div></div>

<p>File uploads often require additional information to be transferred to the server, e.g. a JSON data object representing the entity to be associated with the data contained in the file. This can be handled using <i>multipart requests</i>. A multipart request consists of multiple body parts that can have different content types. To create such a request, on the <i>RequestBuilder</i> interface the <i>multiPart()</i> method has to be called for each part to be added. The method expects a name for the new part and a consumer for a <i>RequestBodyBuilder</i>. The latter is used to set the actual content of the part. For this all the facilities shown in the previous examples are available. The code fragment below demonstrates the construction of a multipart request with three parts, a JSON part, a plain text part, and a file upload part:</p>

<div>
<div>
<pre class="source">httpClient.execute(builder -&gt;
    builder.uri(endpointUri())
        .method(RequestBuilder.Method.POST)
        .multiPart(&quot;json&quot;, body -&gt; body.json(jsonObj))
        .multiPart(&quot;plain&quot;, body -&gt; body.string(CONTENT, CONTENT_TEXT_PLAIN))
        .multiPart(&quot;file&quot;, body -&gt; body.file(testFilePath, CONTENT_OCTET_STREAM)), ...
</pre></div></div>
</div>
<div class="section">
<h3><a name="Processing_responses"></a>Processing responses</h3>
<p>The <i>execute()</i> method of <i>HttpClient</i> generates the request defined via the builder and sends it to the target server. If sending fails or no response is received - e.g. because of network or connection problems -, the <i>CompletableFuture</i> returned by <i>execute()</i> fails with a corresponding exception. Otherwise, from the response of the server a <i>Response</i> object is created, and this object is passed to the <i>ResponseProcessor</i> provided as second parameter to <i>execute()</i>. The processor can use this information to create a result object, which becomes the result of the <i>CompletableFuture</i>. Alternatively, the processor can throw an <i>IOException</i> (e.g. if the response indicates an error); in this case, the future completes with this exception.</p>
<p>The <i>Response</i> interface provides access to the well-known properties of an HTTP response: * The HTTP status code can be queried using the <i>statusCode()</i> method. * Headers set by the server are available via the methods <i>headerNames()</i> and <i>header()</i>. * The request body can be retrieved as a (potentially empty) stream via the <i>bodyStream()</i> method.</p>
<p>It is up to a concrete <i>ResponseProcessor</i> implementation how this information is evaluated to construct a result object. Normally, the response has to be validated (e.g. by checking the status code or other properties), then the body is read, and based on this a result can be generated (maybe using JSON de-serialization). As some of these steps need to be repeated for each request, there are some helper functions in the <i>HttpUtils</i> class to simplify things a bit; they will be introduced shortly. First we give a full example of a request execution with a response processor that just returns the response body as a string:</p>

<div>
<div>
<pre class="source">CompletableFuture&lt;String&gt; futResponse =
        httpClient.execute(builder -&gt; builder.uri(endpointUri()), resonponse -&gt; {
            if (!response.isSuccess()) {
                return &quot;error&quot;;
            }
            else {
                return IOUtils.toString(response.bodyStream(), StandardCharsets.UTF_8);
            }
        }
);
</pre></div></div>

<p>This example uses a <i>ResponseProcessor</i> implementation that first checks the HTTP status and - if successful - reads the content of the response body into a string. Note that it is not necessary to close the input stream; this is handled by the framework automatically.</p></div></div>
<div class="section">
<h2><a name="Utility_functions"></a>Utility functions</h2>
<p>The <i>HttpUtils</i> class contains a number of helper functions to simplify typical tasks related to sending and processing of HTTP requests. In many cases, these simplify the implementation of custom response processors or even make it unnecessary. This section gives an overview over this functionality.</p>
<div class="section">
<h3><a name="Simplified_GET_requests"></a>Simplified GET requests</h3>
<p>If only a simple GET request is to be executed without headers, it is not necessary to write a lambda expression that interacts with a <i>RequestBuilder</i>. The <i>HttpUtils.get()</i> method provides a corresponding implementation. Its result can be passed as first argument to <i>HttpClient</i>&#x2019;s <i>execute()</i> method:</p>

<div>
<div>
<pre class="source">httpClient.execute(HttpUtils.get(&quot;https://my-server.com/endpoint&quot;), ...
</pre></div></div>
</div>
<div class="section">
<h3><a name="Checking_the_response_status"></a>Checking the response status</h3>
<p>When processing the response of a request it is often necessary to check the HTTP status code; only if the status indicates a successful response, further evaluation of the response body should be done. <i>HttpUtils</i> provides a number of functions that handle such checks. The idea behind these functions is that they expect a <i>ResponseProcessor</i> as argument and return another one as result. They implement specific checking logic and only delegate to the passed in processor if the checks are successful. Thus, a custom <i>ResponseProcessor</i> can assume a success status and focus on the actual processing logic. Instead of the original processor, the one returned by the functions needs to be passed to the HTTP client.</p>
<p>The functions are named <i>checkResponse()</i>. There are multiple overloaded variants; they support the following arguments: * the original <i>ResponseProcessor</i>; as has already been explained, this processor is decorated with the checking logic. * a predicate defining the checking logic. This is a function that expects a <i>Response</i> object and returns a <i>boolean</i> result indicating whether the response is successful. * a tag to assign a name to the request. This string appears in exceptions reporting failed requests. This is especially useful if requests are chained via <i>CompletableFuture</i> mechanisms; it is then not always obvious, which request has caused the failure.</p>
<p>There are variants of <i>checkResponse()</i> that do not expect a predicate, but use a default one which just checks whether the HTTP status is in the successful range. This may be sufficient for many use cases. If more control is needed, the <i>hasStatus()</i> function is a candidate: it is passed a status code, and it returns <i>true</i> if and only if a response has exactly this status.</p></div>
<div class="section">
<h3><a name="JSON_deserialization_support"></a>JSON deserialization support</h3>
<p>When dealing with JSON APIs server responses often have to be transformed into Java object representations. This is possible with the <i>jsonResult()</i> functions of <i>HttpUtils</i>. The functions require a JSON object mapper as argument. They use this object to convert the entity of a response to a Java object whose type is determined either by a class or a type reference.</p>
<p>Note that the _ResponseProcessor_s returned by these functions directly access the entity content without doing checks of the status code; but they can be combined with the <i>checkResponse()</i> functions discussed earlier to achieve this. Below is an example of a GET request that is converted to a model object:</p>

<div>
<div>
<pre class="source">CompletableFuture&lt;JsonBean&gt; response = httpClient.execute(HttpUtils.get(endpointUri()),
        HttpUtils.checkResponse(HttpUtils.jsonResult(mapper, JsonBean.class)));
</pre></div></div>
</div>
<div class="section">
<h3><a name="Blocking_requests"></a>Blocking requests</h3>
<p>The API of <i>HttpClient</i> to execute requests is asynchronous per default, which gives the highest flexibility and enables sending many requests efficiently. For some simple use cases, however, the easier blocking programming model may be a better fit. If you just want to execute a single request and have the result available, it may be inconvenient to deal with futures.</p>
<p>For such cases, the <i>HttpUtils</i> class offers the <i>waitFor()</i> function. The function expects a <i>Future</i> of a specific type, waits (in a blocking manner) for the completion of this future, and returns its result. If the future completes with an exception, the exception is wrapped in an <i>IOException</i> and thrown; thus callers do not have to deal with the various exceptions thrown by <i>Future.get()</i>.</p>
<p>The <i>waitFor()</i> function offers an easy to use means to convert the asynchronous API for request execution to a synchronous one. The example below shows a typical usage:</p>

<div>
<div>
<pre class="source">ResponseProcessor&lt;JsonBean&gt; processor = HttpUtils.jsonResult(mapper, JsonBean.class);
try {
    JsonBean result = HttpUtils.waitFor(httpClient.execute(HttpUtils.get(endpoint()), processor));
    // do something with result
} catch (IOException e) {
    // exception handling
} 
</pre></div></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2020.
All rights reserved.</p>
        </div>
        </div>
    </footer>
    </body>
</html>
