/*
 * Copyright (c) Bosch Software Innovations GmbH 2019.
 * Copyright (c) Bosch.IO GmbH 2020.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.antenna.sw360.client.rest;

import org.eclipse.sw360.antenna.http.api.RequestProducer;
import org.eclipse.sw360.antenna.http.api.ResponseProcessor;
import org.eclipse.sw360.antenna.http.utils.FailedRequestException;
import org.eclipse.sw360.antenna.http.utils.HttpConstants;
import org.eclipse.sw360.antenna.http.utils.HttpUtils;
import org.eclipse.sw360.antenna.sw360.client.SW360ClientConfig;
import org.eclipse.sw360.antenna.sw360.client.auth.AccessToken;
import org.eclipse.sw360.antenna.sw360.client.auth.AccessTokenProvider;

import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import static org.eclipse.sw360.antenna.http.utils.HttpConstants.URL_PATH_SEPARATOR;

/**
 * <p>
 * A base class for all classes that interact with SW360 REST endpoints.
 * </p>
 * <p>
 * This class provides a generic mechanism for the execution of HTTP requests
 * to an SW360 server. Requests are sent asynchronously, and authentication
 * information is added automatically. There is also a retry logic in place
 * that checks for expired access tokens.
 * </p>
 * <p>
 * The intended usage is that special client implementations providing CRUD
 * operations on specific SW360 REST resources extend this base class and make
 * use of the generic HTTP execution mechanism.
 * </p>
 */
public abstract class SW360Client {
    /**
     * The configuration for this client.
     */
    private final SW360ClientConfig clientConfig;

    /**
     * The object to obtain access tokens.
     */
    private final AccessTokenProvider tokenProvider;

    /**
     * Creates a new instance of {@code SW360Client} with the given
     * dependencies.
     *
     * @param config        the configuration of this client
     * @param tokenProvider the provider for access tokens
     */
    protected SW360Client(SW360ClientConfig config, AccessTokenProvider tokenProvider) {
        this.clientConfig = config;
        this.tokenProvider = tokenProvider;
    }

    /**
     * Returns the SW360 client configuration used by this client.
     *
     * @return the {@code SW360ClientConfig}
     */
    public SW360ClientConfig getClientConfig() {
        return clientConfig;
    }

    /**
     * Returns the {@code AccessTokenProvider} used by this client.
     *
     * @return the {@code AccessTokenProvider}
     */
    public AccessTokenProvider getTokenProvider() {
        return tokenProvider;
    }

    /**
     * Executes a request to SW360 with authentication and retry logic. This
     * method wraps the {@code RequestProducer} to automatically add a current
     * access token. It also inspects the result and checks whether it has a
     * failed response status. In case of a 401 Unauthorized status, it is
     * assumed that the token became invalid, and the request is retried with a
     * fresh token. If the retried request fails again with 401, we give up and
     * report the failure.
     *
     * @param producer  the {@code RequestProducer}
     * @param processor the {@code ResponseProcessor} (does not need to handle
     *                  response status codes)
     * @param tag       a tag to identify the request
     * @param <T>       the type of the {@code ResponseProcessor}
     * @return a future with the result generated by the {@code ResponseProcessor}
     */
    protected <T> CompletableFuture<T> executeRequest(RequestProducer producer, ResponseProcessor<T> processor,
                                                      String tag) {
        return executeWithExpiredTokenCheck(producer, processor, tag, true);
    }

    /**
     * Executes a request to SW360 with authentication and retry logic that
     * expects a JSON response. This method performs the same checks as
     * {@code executeRequest()}, but it creates the {@code ResponseProcessor}
     * automatically that can convert the JSON response to the desired target
     * type.
     *
     * @param producer    the {@code RequestProducer}
     * @param resultClass the class to which the JSON payload is to be
     *                    converted
     * @param tag         a tag to identify the request
     * @param <T>         the type of the result
     * @return a future with the result of the request
     */
    protected <T> CompletableFuture<T> executeJsonRequest(RequestProducer producer, Class<T> resultClass, String tag) {
        return executeRequest(producer,
                HttpUtils.jsonResult(getClientConfig().getObjectMapper(), resultClass), tag);
    }

    /**
     * Generates a URL pointing to a specific resource of the SW360 server.
     * This method concatenates the given path segments and appends them to the
     * base REST URL of the server. It can be used by derived classes to
     * generate the URLs to be requested.
     *
     * @param paths the path segments to add to the base URL
     * @return a string with the resulting URL
     */
    protected String resourceUrl(String... paths) {
        return getClientConfig().getRestURL() + URL_PATH_SEPARATOR + String.join(URL_PATH_SEPARATOR, paths);
    }

    /**
     * Implements the actual request execution logic including a retry
     * mechanism if the current access token may have expired. This method
     * generates a future that obtains the current access token and executes
     * the request defined by the parameters with it. If the {@code canRetry}
     * parameter is <strong>true</strong> (which it is only for the first time
     * the request is executed), the future is enhanced with special retry
     * logic. This logic checks whether a failure has occurred indicating an
     * expired access token. If this is the case, another request execution is
     * chained to the original future.
     *
     * @param producer  the {@code RequestProducer}
     * @param processor the {@code ResponseProcessor}
     * @param tag       a tag to identify the request
     * @param canRetry  a flag whether a retry is possible
     * @param <T>       the type of the result
     * @return a future with the result of the request
     */
    private <T> CompletableFuture<T> executeWithExpiredTokenCheck(RequestProducer producer,
                                                                  ResponseProcessor<T> processor,
                                                                  String tag,
                                                                  boolean canRetry) {
        CompletableFuture<T> futRequest = getTokenProvider().doWithToken(accessToken ->
                getClientConfig().getHttpClient().execute(accessToken.tokenProducer(producer),
                        applyChecks(processor, tag, accessToken)));
        return canRetry ? futRequest.handle((result, wrappedException) ->
                checkIfRetry(futRequest, wrappedException))
                .thenCompose(optFuture -> optFuture.orElseGet(() ->
                        executeWithExpiredTokenCheck(producer, processor, tag, false))) :
                futRequest;
    }

    /**
     * Checks whether a request needs to be retried because the access token
     * may have expired. The method checks whether the request failed with the
     * special {@code RequestUnauthorizedException} exception. If so, result is
     * an empty optional, meaning that a result is not yet available.
     * Otherwise, the optional contains the future to be returned to the
     * caller.
     *
     * @param futRequest       the future with the result of the request execution
     * @param wrappedException the exception the request failed with if any
     * @param <T>              the result type of the request
     * @return an {@code Optional} with the result to be returned
     */
    private <T> Optional<CompletableFuture<T>> checkIfRetry(CompletableFuture<T> futRequest,
                                                            Throwable wrappedException) {
        Throwable exception = HttpUtils.unwrapCompletionException(wrappedException);
        if (exception instanceof UnauthorizedRequestException) {
            getTokenProvider().invalidate(((UnauthorizedRequestException) exception).token);
            return Optional.empty();
        } else {
            return Optional.of(futRequest);
        }
    }

    /**
     * Checks whether the given exception indicates an unauthorized request.
     * This could mean that the access token has expired, and the request may
     * be retried with a fresh token.
     *
     * @param exception the exception causing the request to fail
     * @return true if the request was unauthorized, false otherwise
     */
    private static boolean isRequestUnauthorized(Throwable exception) {
        return exception instanceof FailedRequestException &&
                ((FailedRequestException) exception).getStatusCode() == HttpConstants.STATUS_ERR_UNAUTHORIZED;
    }

    /**
     * Adds some checks to the original {@code ResponseProcessor} for a request
     * to be executed. Before this processor is invoked, it is first checked
     * whether the response has a successful status code. The status code
     * indicating an unauthorized request is handled in a special way as it
     * might cause the request to be retried.
     *
     * @param processor   the original {@code ResponseProcessor}
     * @param tag         a tag to identify the request
     * @param accessToken the current access token
     * @param <T>         the type of the result
     * @return the decorated {@code ResponseProcessor}
     */
    private static <T> ResponseProcessor<T> applyChecks(ResponseProcessor<T> processor, String tag,
                                                        AccessToken accessToken) {
        return checkUnauthorized(HttpUtils.checkResponse(processor, tag), tag, accessToken);
    }

    /**
     * Returns a special {@code ResponseProcessor} that wraps another processor
     * and checks whether the request failed because it was unauthorized. In
     * this case, the exception is transformed and enriched with the (probably
     * expired) access token.
     *
     * @param processor the {@code ResponseProcessor} to be wrapped
     * @param token     the current access token
     * @param <T>       the type of the result generated
     * @return the result of the {@code ResponseProcessor}
     */
    private static <T> ResponseProcessor<T> checkUnauthorized(ResponseProcessor<T> processor, String tag,
                                                              AccessToken token) {
        return response -> {
            try {
                return processor.process(response);
            } catch (FailedRequestException e) {
                if (isRequestUnauthorized(e)) {
                    throw new UnauthorizedRequestException(tag, token);
                } else {
                    throw e;
                }
            }
        };
    }

    /**
     * A special exception class to indicate that a request failed because it
     * was unauthorized. Such requests may be retried with a fresh access
     * token. The main purpose of this class is to transport the access token
     * through the processing chain, so that it can be invalidated.
     */
    private static class UnauthorizedRequestException extends FailedRequestException {
        private final AccessToken token;

        public UnauthorizedRequestException(String tag, AccessToken token) {
            super(tag, HttpConstants.STATUS_ERR_UNAUTHORIZED);
            this.token = token;
        }
    }
}
